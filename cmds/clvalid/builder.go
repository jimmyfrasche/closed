package main

import (
	"fmt"
	"go/types"
	"io"

	"github.com/jimmyfrasche/closed"
	"github.com/jimmyfrasche/closed/cmds/internal/closedutil"
)

type Generator struct {
	*Writer

	ToolName string

	T     *Type
	tqual string

	FName string
	Func  bool

	BuildTags []byte

	PackageName string

	ThisPackageImp string
	ImportNames    map[string]string
	Imports        []string
}

func (g *Generator) qual(imp string) string {
	if imp == g.ThisPackageImp {
		return ""
	}
	return fmt.Sprintf("%s.", g.ImportNames[imp])
}

func (g *Generator) typesQual(p *types.Package) string {
	imp := p.Path()
	if imp == g.ThisPackageImp {
		return ""
	}
	return g.ImportNames[imp]
}

func (g *Generator) Generate(w io.Writer) error {
	g.Writer = &Writer{
		w: w,
	}
	g.tqual = g.qual(g.T.Pkg.ImportPath)

	g.header()
	g.decl()

	// fill in the body
	if closedutil.AlwaysValid(g.T.T) {
		g.println("return nil")
	} else {
		switch c := g.T.T.(type) {
		case *closed.Interface:
			g.interfaceSum(c)
		case *closed.EmptySum:
			g.emptySum(c)
		case *closed.Enum:
			g.enum(c)
		case *closed.Bitset:
			g.bitset(c)
		case *closed.OptionalStruct:
			g.optionalStruct(c)
		default:
			return fmt.Errorf("%s out of date: unknown closed type %T", g.ToolName, c)
		}
	}

	g.println("}") //close off func declaration

	return g.err
}

func (g *Generator) header() {
	g.printf("// Code generated by %s - DO NOT EDIT.\n\n", g.ToolName)

	if len(g.BuildTags) > 0 {
		g.write(g.BuildTags)
	}

	g.printf("package %s\n", g.PackageName)

	g.println("import (")
	g.println(`"fmt"`) //for fmt.Errorf
	for _, imp := range g.Imports {
		g.println(imp)
	}
	g.println(")")
}

func (g *Generator) decl() {
	g.printf("//%s checks that v is a legal value of %s.\n", g.FName, g.T.Name)

	g.print("func ")
	if g.Func {
		g.printf("%s(v %s%s)", g.FName, g.tqual, g.T.Name)
	} else {
		g.printf("(v %s%s) %s", g.tqual, g.T.Name, g.FName)
	}
	g.println(" error {")
}

func (g *Generator) comma(n int, len int) {
	if n != len-1 {
		g.print(",")
	}
}

func (g *Generator) interfaceSum(c *closed.Interface) {
	g.println("switch v.(type) {")

	g.print("case nil")
	if c.NonNil {
		g.println(":")
		//Note that %T is evaluated now
		g.printf(`return fmt.Errorf("%T must not be nil")`, g.T.Name)
		g.print("\ncase ")
	} else {
		g.print(",")
	}

	for i, m := range c.Members {
		//prefer exported names:
		//if this is an external type, this is required and verified not to fail
		//otherwise, it is harmless.
		m0 := closedutil.FirstExportedTypeName(m.TypeName)
		if m0 == nil {
			m0 = m.TypeName[0]
		}

		ptr := ""
		if _, ok := m.Type.(*types.Pointer); ok {
			ptr = "*"
		}

		g.printf("%s%s%s", ptr, g.tqual, m0.Name())

		g.comma(i, len(c.Members))
	}
	g.println(": return nil")

	g.println("}")

	g.printf(`return fmt.Errorf("type %%T is not a legal type of %s", v)`, g.T.Name)
}

func (g *Generator) emptySum(c *closed.EmptySum) {
	g.println("switch v.(type) {")

	g.print("case nil")
	if c.Nil {
		g.print(",")
	} else {
		g.printf(`: return fmt.Errorf("%s must not be nil")`, g.T.Name)
		g.print("\ncase ")
	}

	for i, m := range c.Members {
		g.print(types.TypeString(m, g.typesQual))

		g.comma(i, len(c.Members))
	}
	g.println(": return nil")

	g.println("}")

	g.printf(`return fmt.Errorf("%%T is not a legal type of %s", v)`, g.T.Name)
}

func (g *Generator) enum(c *closed.Enum) {
	doZ := !c.NonZero && !closedutil.ContainsLabeledZero(c)
	if doZ {
		g.printf("var z %s%s", g.tqual, g.T.Name)
	}

	g.println("switch v {")
	g.print("case ")
	if doZ {
		g.print("z,")
	}

	for i, L := range c.Labels {
		g.printf("%s%s", g.tqual, closedutil.FirstExportedLabel(L).Name())

		g.comma(i, len(c.Labels))
	}
	g.println(": return nil")

	g.println("}")

	g.printf(`return fmt.Errorf("%%v is not a legal value of %s", v)`, g.T.Name)
}

func (g *Generator) bitset(c *closed.Bitset) {
	all := fmt.Sprintf("0x%X", closedutil.AllMask(c))
	g.printf("if v &^ %s == 0 { return nil }\n", all)
	g.printf(`return fmt.Errorf("%s has illegal bits set %%b", v &^ %s)`, g.T.Name, all)
}

func (g *Generator) optionalStruct(c *closed.OptionalStruct) {
	//create zero value of c.Field
	g.print("var z ")
	g.println(types.TypeString(c.Field.Type(), g.typesQual))

	dn := c.Discriminant.Name()
	fn := c.Field.Name()
	g.printf("if !v.%s && v.%s != z {\n", dn, fn)
	g.printf(`return fmt.Errorf("it is not legal to set %s unless %s is false")`, fn, dn)
	g.println("}")

	g.println("return nil")
}
