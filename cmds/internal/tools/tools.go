package tools

import (
	"bufio"
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"io"
	"os"
	"os/exec"
	"regexp"
	"strings"

	"golang.org/x/tools/go/buildutil"
)

//AddTagsFlag registers the buildutil.TagsFlag flag.
func AddTagsFlag(fs *flag.FlagSet, to *[]string) {
	fs.Var((*buildutil.TagsFlag)(to), "tags", buildutil.TagsFlagDoc)
}

//AddTagsFlagDefault calls AddTagFlag with the default flag set and build context.
func AddTagsFlagDefault() {
	AddTagsFlag(flag.CommandLine, &build.Default.BuildTags)
}

//unparseTagsFlag converts parsed build tags back into a command line argument.
func unparseTagsFlag(tags []string) string {
	if len(tags) == 0 {
		return ""
	}
	for i, t := range tags {
		tags[i] = "'" + t + "'"
	}
	return "-tags=" + strings.Join(tags, " ")
}

//MakeFileCheck creates a file checker for go/parser.ParseDir.
func MakeFileCheck(files []string) func(os.FileInfo) bool {
	return func(fi os.FileInfo) bool {
		nm := fi.Name()
		for _, f := range files {
			if f == nm {
				return true
			}
		}
		return false
	}
}

//FilesToSlice returns pkg.Files as a slice.
func FilesToSlice(pkg *ast.Package) []*ast.File {
	var acc []*ast.File
	for _, f := range pkg.Files {
		acc = append(acc, f)
	}
	return acc
}

//GoList invokes "go list" with args and returns the output.
//
//It outputs errors from go list directly to stderr.
func GoList(buildTags, args []string) ([]string, error) {
	Args := []string{"list"}
	if bt := unparseTagsFlag(buildTags); bt != "" {
		Args = append(Args, bt)
	}
	Args = append(Args, "--")
	Args = append(Args, args...)
	return execCollect(exec.Command("go", Args...))
}

//PackageName gets the name of the package at import path imp via go list.
func PackageName(buildTags []string, imp string) (string, error) {
	args := []string{"list", "-f", "{{.Name}}"}
	if bt := unparseTagsFlag(buildTags); bt != "" {
		args = append(args, bt)
	}
	args = append(args, "--", imp)
	out, err := execCollect(exec.Command("go", args...))
	if err != nil {
		return "", err
	}
	if len(out) != 1 {
		if len(out) == 0 {
			return "", fmt.Errorf("invalid import path %q", imp)
		}
		return "", fmt.Errorf("expected 1 result from go list %q, got %d", imp, len(out))
	}
	return out[0], nil
}

//Deps gets the transitive dependencies of import path imp from go list.
func Deps(buildTags []string, imp string) ([]string, error) {
	args := []string{"list", "-f", "{{range .Deps}}{{.}}\n{{end}}"}
	if bt := unparseTagsFlag(buildTags); bt != "" {
		args = append(args, bt)
	}
	args = append(args, "--", imp)
	out, err := execCollect(exec.Command("go", args...))
	if err != nil {
		return nil, err
	}
	return out, nil
}

//Rdeps invokes rdeps on import path imp to gather its reverse dependencies.
//
//rdeps is part of honnef.co/go/tools/...
func Rdeps(buildTags []string, imp string) ([]string, error) {
	if imp == "" {
		return nil, errors.New("rdeps requires import path")
	}
	var args []string
	if bt := unparseTagsFlag(buildTags); bt != "" {
		args = append(args, bt)
	}
	args = append(args, "--", imp)
	return execCollect(exec.Command("rdeps", args...))
}

func execCollect(cmd *exec.Cmd) ([]string, error) {
	cmd.Stderr = os.Stderr
	r, err := cmd.StdoutPipe()
	if err != nil {
		return nil, err
	}

	if err := cmd.Start(); err != nil {
		return nil, err
	}

	scan := bufio.NewScanner(r)
	var pkgs []string
	for scan.Scan() {
		pkgs = append(pkgs, scan.Text())
	}
	if err := scan.Err(); err != nil {
		return nil, err
	}

	if err := cmd.Wait(); err != nil {
		return nil, fmt.Errorf("%s: %s", cmd.Path, err)
	}
	return pkgs, nil
}

//OverwriteCheck return nil if filename does not exist
//or if it does but was created by toolname.
//
//This is of course racy so it cannot prevent many errors,
//but it can catch some silly human-scale mistakes.
func OverwriteCheck(filename, toolname string) error {
	if filename == "/dev/stdout" { //used for manual testing
		return nil
	}
	f, err := os.Open(filename)
	if err != nil {
		if os.IsNotExist(err) {
			return nil
		}
		return err
	}
	defer f.Close()

	cmt := "// Code generated by " + toolname + " - DO NOT EDIT.\n"
	p := make([]byte, len(cmt))
	_, err = f.Read(p)
	if err != nil {
		return err
	}
	if string(p) != cmt {
		return fmt.Errorf("%s was not created by %s", filename, toolname)
	}
	return nil
}

//format for auto code: // Code generated by «.Name». DO NOT EDIT.

//Gofmt the template to file.
//
//The template should contain
//	// Code generated by {name} - DO NOT EDIT.
//on the first line as OverwriteCheck expects that exact format and placement.
func Gofmt(file string, write func(io.Writer) error) error {
	f, err := os.Create(file)
	if err != nil {
		return err
	}
	defer f.Close()
	out := bufio.NewWriter(f)
	defer out.Flush()

	cmd := exec.Command("gofmt")
	cmd.Stderr = os.Stderr
	cmd.Stdout = out
	w, err := cmd.StdinPipe()
	if err != nil {
		return err
	}

	if err := cmd.Start(); err != nil {
		return err
	}
	err = write(struct{ io.Writer }{w})
	_ = w.Close()
	if err != nil {
		return err
	}
	return cmd.Wait()
}

var (
	pkgClause = regexp.MustCompile(`^[ \t]*package[ \t]`)
	buildTag  = regexp.MustCompile(`^[ \t]*//[ \t]+\+build[ \t]`)
)

func BuildTagsFrom(filename string) ([]byte, error) {
	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	var tags []byte
	lastWasTag := false
	scanner := bufio.NewScanner(f)

	//scan until we hit a package clause or find build tags
loop:
	for scanner.Scan() {
		bs := scanner.Bytes()

		switch {
		case pkgClause.Match(bs):
			break loop

		case buildTag.Match(bs):
			tags = append(tags, bs...)
			tags = append(tags, '\n')
			lastWasTag = true

		case len(bytes.TrimSpace(bs)) == 0:
			if lastWasTag {
				tags = append(tags, '\n')
				break loop
			}
			lastWasTag = false

		default:
			tags = tags[:0]
			lastWasTag = false
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}
	return tags, nil
}
